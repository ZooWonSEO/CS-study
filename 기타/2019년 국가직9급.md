### CPU 내부 레지스터

- 제어장치  
1) 프로그램 카운터 (PC) : 다음에 실행할 명령어 주소 저장   
2) 메모리 주소 레지스터 (MAR) : 명령이나 데이터의 주소 임시저장     
3) 메모리 버퍼 레지스터 (MBR) : 기억장치로부터 읽혀진 데이터 임시저장     
4) 명령어 레지스터 (IR) : 현재 실행중인 명령어 코드 저장    
5) 명령 해독기 (ID) : 명령어를 실행할 수 있게 해독  

<br>

- 연산장치  
1) 누산기 (AC) : 연산 과정의 데이터를 임시저장  
2) 가산기 : 더하기  
3) 보수기 : 빼기  
4) 데이터 레지스터 (DR)  
5) 상태 레지스터 (SR)  

<br>

### 프로세스 vs 스레드

- 프로세스  
1. 프로세스의 구성은 제어흐름(실행)부분과 실행환경 부분으로 분리가 가능하다.  
2. 하나의 프로세스에는 한 개 또는 여러 개의 스레드가 포함될 수 있다.  

<br>

- 스레드 
1. 프로세스의 실행부분을 담당하여 실행의 기본단위   
2. 하나의 스레드는 여러 프로세스에 포함될 수 없다.   
3. 프로세스와 같이 스레드도 중앙처리장치를 공유하며, 한 순간에 오직 하나의 스레드만이 수행한다.  

<br>

### 정규화 과정

1NF : 원자값 분해  
2NF : 부분함수 종속제거  
3NF : 이행함수 종속제거  
BCNF : 결정자가 후보키가 아닌 함수 종속제거  
4NF : 함수종속이 아닌 다치종속 제거  
5NF : 후보키를 통하지 않은 조인종속 제거  

<br>

### TCP vs UDP

- TCP  
1. 연결기반이며, 안정성과 순서를 보장한다.  
2. 패킷을 자동으로 나눠준다.  
3. 혼잡제어 : 통신망 특정 부분에 트래픽이 몰리는 것을 방지  
4. 파일을 쓰는 것처럼 사용하기 쉽다.  

- UDP
1. 연결기반이 아니며, 안정성과 순서를 보장하지 않는다.  
2. 직접 패킷을 나눠야 한다.  

<br>

### IP 단편화

- MTU(Maximum transmission unit)  
링크 계층 프레임이 전달할 수 있는 최대 데이터 양   

- IP 단편화, 재결합에 필요한 옵션  
식별자, 플래그, 단편화 오프셋  

- 오프셋은 첫번째 단편의 페이로드 / 8(바이트)  

<br>

### GBn vs SR 프로토콜
- Go-Back-N 프로토콜  
잘못된 패킷 번호부터 다시 재전송하는 기법  

- Selective Repeat 프로토콜  
잘못받은 패킷 번호만 다시 재전송하는 기법

<br>

### FIFO 알고리즘
FIFO = FCFS (First Come First Service)로 큐로 쉽게 관리한다.  
Convoy Effect 발생 : Burst Time(실행시간)이 긴 프로세스가 CPU 독점  
단독사용하지 않고, 다른 스케쥴링에 보조적으로 사용  

<br>

### 코드 번역
원시코드 -> 컴파일러 -> 목적코드 -> 링커 -> 로드모듈 -> 로더 -> 실행결과  

- 컴파일러  
컴파일 언어로 작성된 원시프로그램을 준기계어로 번역해 목적코드로 번역  
  
- 링커  
재배치 형태의 기계어로 된 여러 개의 프로그램을 묶어 하나의 기계어로 번역  
  
- 어셈블러  
어셈블리어로 작성된 원시코드를 번역해 주는 번역기  
  
- 프리프로세서(전처리기)  
특정 고급언어로 작성된 프로그램을 다른 고급언어로 번역  

<br>

### 마이크로프로세서 클럭
1. 클럭주기는 클럭 사이클의 지속시간  
2. 명령의 실행시간은 클럭주기와 같거나 크다.  
3. CISC는 많은 명령어, 복잡함, 가변 길이 명령어, 다양한 방식, 마이크로프로그래밍 제어  
4. RISC는 적은 명령어, 단순함, 고정 길이 명령어, 단순 방식, Pipelining, 하드와이어 제어  

<br>

### 기능점수
외부입력, 외부출력, 외부조회, 외부연계파일, 내부논리파일  


### SW개발 프로세스  
- SDLC (SoftWare Development Life Cycel)  
SW 개발 생명주기를 기반으로 정의  

<br>

1) 폭포수모델(Waterfall model)  
SW개발을 순차적으로 진행하는 프로세스 모델  
순서 : 계획 -> 요구분석 -> 설계 -> 구현 -> 테스트 -> 운영,유지보수  
  
2) V모델  
폭포수모델에 테스트(검증) 단계가 추가 확장된 모델  
순서 : 요구분석 -> 시스템설계 -> 상세설계 -> 코딩 -> 단위테스트 -> 통합테스트 -> 시스템테스트 -> 인수테스트  
  
3) 프로토타이핑모델(Prototyping Model), 원형모델  
프로토타입을 먼저 만들고 이를 바탕으로 개발하는 방식  
순서 : 요구분석 -> 설계 -> 프로토타입개발 -> 고객평가 -> 프로토타입정제 -> 완제품 생산  
  
4) 나선형 모델   
점진적으로 완벽한 시스템으로 개발해 나가는 모델  
순서 : 요구분석 -> 위험분석 -> 개발 및 검증 -> 사용자 평가  
  
5) 진화적 모델  
개발버전에 따라 먼저 출시하고 피드백을 반영하며 진화개발하는 모델  

<br>

### RAID (Redundant Array of Independent Disk)
[개념] : 여러개의 하드디스크에 일부 중복된 데이터를 나눠 저장하는 기술  
[종류]  
1) RAID0(Striping)    : 데이터를 여러 디스크에 분산 저장한다.  
2) RAID1(Mirroring)   : 데이터를 두 개 이상의 디스크에 패리티 없이 중복 저장한다.    
3) RAID2(Hamming)     : 데이터를 비트 단위로 분산 저장하고 여러개의 해밍코드 검사디스크를 사용한다.  
4) RAID3              : 데이터를 바이트 단위로 분산 저장하고 전용 패리티 검사디스크를 사용한다.  
5) RAID4(Parity)      : 데이터를 블록 단위로 분산 저장하고 저장시 매번 패리티 정보를 갱신한다.  
6) RAID5(분산 패리티)  : 패리티정보를 모든 디스크에 분산 저장하고 다중사용자 환경에서 좋다. 최소3개필요.  
7) RAID6(Dual Parity) : 이중 분산 패리티 구성을 포함해 장애대비능력이 높다. 복구시간이 길다.  

<br> 

